/*
Project 1
@authors: Federico Melo Barrero, f.melo, 202021525
		  Germ√°n Alberto Rojas Cetina, g.rojasc, 202013415

Please rename file to 'Robot.jj' before using.
*/


options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
}


PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.awt.Point;
import java.io.*;
import java.util.*;

@SuppressWarnings("serial")
public class Robot 
{
	private RobotWorldDec world;


	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}


	private String salida = new String();

	private ArrayList<String> declaredVars = new ArrayList<String>();
	private Hashtable<String, Integer> vars = new Hashtable<String, Integer>();
	private ArrayList<String> procsNames = new ArrayList<String>();
	private Hashtable<String, ArrayList<String>> procsParams = new Hashtable<String, ArrayList<String>>();
	private Hashtable<String, ArrayList<String>> procsInstrs = new Hashtable<String, ArrayList<String>>();
}

PARSER_END(Robot)


SKIP:
{
		" "
	|	"\r"
	|	"\t"
	|	"\n"
}


/* Commands */
TOKEN: 
{
		< STEP: "step" >
	|	< JUMP: "jump" >
	|	< JUMPTO: "jumpTo" >
	|	< VEER: "veer" >
	|	< LOOK: "look" >
	|	< DROP: "drop" >
	|	< GRAB: "grab" >
	|	< GET: "get" >
	|	< FREE: "free" >
	|	< POP: "pop" >
	| 	< DMOVE:  "Dmove" >
	|	< OMOVE:  "Omove" >
}


/* Control structures */
TOKEN :
{
		< IF: "if" >
	|	< FI: "fi" >
	|	< ELSE: "else" >
	| 	< WHILE: "while" >
	|	< DO: "do" >
	| 	< OD: "od" >
	|	< REPEATTIMES: "repeatTimes" >
	|	< PER : "per" >
}


/* Conditions */
TOKEN :
{
		< ISFACING : "isfacing" >
	| 	< ISVALID: "isValid" >
	| 	< CANMOVE: "canMove" >
	| 	< NOT: "not" >
	|	< PICK:  "pick" > // For isValid condition
}


/* Cardinal directions */
TOKEN :
{
	 	< NORTH: "north" >
	| 	< SOUTH: "south" >
	| 	< EAST: "east" >
	| 	< WEST: "west" >
}


/* Directions */
TOKEN :
{
		< AROUND: "around" >
	| 	< RIGHT: "right" >
	| 	< LEFT: "left" >
	| 	< FRONT: "front" >
	| 	< BACK: "back" >
}


/* Keywords */
TOKEN :
{
		< PROG: "PROG" >
	|	< GORP: "GORP" >
	|	< VAR: "VAR" >
	|	< PROC: "PROC" >
	|	< CORP: "CORP" >
}


/* Name */
TOKEN :
{
		< NAME: <LETTER>(["a"-"z","A"-"Z","0"-"9"])* >
	|  	< #LETTER: ["a"-"z","A"-"Z"] >
}

/* Number */
TOKEN :
{
		< NUM: (<DIGIT>)+ >
	|  	< #DIGIT: ["0"-"9"] >
}


	boolean command(Console sistema):
	{
		salida = "";
	}
	{
		( < PROG > [varDecl()] (procDef())* instrBlock() < GORP >) {
		    try {
	    		Thread.sleep(900);
	    	} catch (InterruptedException e) {
	    		System.err.format("IOException: %s%n", e);
	    	}
			sistema.printOutput(salida);
			return true;
		}
    	| <EOF> {return false;}
	}


	void varDecl():
	{
		String name;
	}
	{
		((< VAR > name=name()) {
			this.declaredVars.add(name);
		} ( LOOKAHEAD(2) "," (name=name()) {
			if (this.declaredVars.contains(name)) {
				throw new Error("Repeated variable name: "+name+ " in variable declaration");
			} else {
				this.declaredVars.add(name);
			}
		} )* ";" ) {
			this.salida = this.salida + "\nVariable declaration";
		}
	}


	void procDef():
	{
		String name;
		ArrayList<String> localVars = new ArrayList<String>();
		ArrayList<String> instructions = new ArrayList<String>();
	}
	{
		 (( < PROC > name=name() "(" [localVars=params()] ")"
		 ) {
			if (procsNames.contains(name)) {
				throw new Error ("Procedure with name "+name+" has already been declared");
			}
			procsNames.add(name);
			procsParams.put(name, localVars);
		} ( procInstrBlock() < CORP > ))
		{ this.salida = this.salida + "\nProcedure definition"; }
	}


	ArrayList<String> params():
	{
		ArrayList<String> localVars = new ArrayList<String>();
		String name;
	}
	{
		((name=name()) {
			localVars.add(name);
		} ( LOOKAHEAD(2) "," (name=name()) {
			if (localVars.contains(name)) {
				throw new Error("Repeated parameter name: "+name);
			} else {
				localVars.add(name);
			}
		} )*) { return localVars; }
	}


	void instrBlock():
	{
	}
	{
		"{" instr() ( LOOKAHEAD(2) ";" instr() )* "}"
	}


	void instr():
	{
	}
	{
		LOOKAHEAD(2) cmd()
	|	ctrlStruct()
	|	procCall()
	}


	void cmd():
	{
		String name;
		Integer n, m;
	}
	{
		((name=name() ":=" n = num()) {
			if (declaredVars.contains(name)) {
				vars.put(name, n);
			} else {
				throw new Error("Tried to assign to undeclared variable "+name);
			}
			this.salida = this.salida + "\nCommand: Variable assignment";
		})
	|	(< STEP >  "(" n = numVar() ")" {world.moveForward(n, false); this.salida = this.salida + "\nCommand: Move steps forward ";})
	|	(< JUMP >  "(" n  = numVar() ")" {world.moveForward(n, true); this.salida = this.salida + "\nCommand: Jump steps forward ";})
	|	(< JUMPTO >  "(" n  = numVar() "," m = numVar()")" {world.setPostion(n,m); this.salida = this.salida + "\nCommand: Jump to position ";})
	|	(< VEER >  "(" veer() ")")
	|	(< LOOK >  "(" look() ")")
	|	(< DROP >  "(" n  = numVar() ")" {world.putChips(n); this.salida = this.salida + "\nCommand: Drop chips from its position ";})
	|	(< GRAB >  "(" n  = numVar() ")" {world.grabBalloons(n); this.salida = this.salida + "\nCommand: Grab balloons from its position ";})
	|	(< GET >  "(" n  = numVar() ")" {world.pickChips(n); this.salida = this.salida + "\nCommand: Get chips from its position ";})
	|	(< FREE >  "(" n  = numVar() ")" {world.putBalloons(n); this.salida = this.salida + "\nCommand: Put balloons from its position ";})
	|	(< POP >  "(" n  = numVar() ")" {world.popBalloons(n); this.salida = this.salida + "\nCommand: Pop balloons from its position ";})
	|	(< DMOVE >  "(" dMove() ")")
	|	(< OMOVE >  "(" oMove() ")")
	}


	void ctrlStruct():
	{
	}
	{
		ifFi()
	|	whileDoOd()
	|	repeatTimes()
	}


	void ifFi():
	{
		boolean bool;
	}
	{
		(< IF > "(" bool=condition() ")"
			"{" instrIf(bool) ( ";" instrIf(bool) )* "}"
		[< ELSE > 
			"{" instrIf(!bool) (  ";" instrIf(!bool) )* "}"
		] < FI >) {
		this.salida = this.salida + "\n'if' conditional control structure";
		}
	}


JAVACODE
	private void instrIf(boolean bool) {
		if (bool) {
			instr();
		} else {
			checkSintaxInstr();
		}
	}


	void whileDoOd():
	{
		ArrayList<String> cond = new ArrayList<String>();
	}
	{
		< WHILE > "(" cond = saveCond() ")" < DO > whileInstrBlock(cond) < OD > {
			this.salida = this.salida + "\n'while' loop control structure";
			}
	}


	void repeatTimes():
	{
		Integer n;
	}
	{
		( < REPEATTIMES > n = numVar() ) repeatInstrBlock(n) ( < PER > ) {
			this.salida = this.salida + "\n'repeatTimes' loop control structure";
		}
	}


	boolean condition():
	{
		boolean bool;
	}
	{
		(< ISFACING >  "(" bool=isFacing() ")"
	|	< ISVALID >  "(" bool=isValid() ")"
	|	< CANMOVE >  "(" bool=canMove() ")"
	|	< NOT >  "(" bool=not() ")") {return bool;}
	}


	void procCall():
	{
		String name;
		ArrayList<String> rParams = new ArrayList<String>();
	}
	{
		(name = name() "(") [rParams = params()] ")" {
			if (!procsNames.contains(name)) {
				throw new Error("Tried to call undeclared procedure");
			}
			if (rParams.size() != procsParams.get(name).size()) {
				throw new Error("Incorrect number of parameters for "+name+" procedure");
			}
			// TODO: Ejecutar el proc llamado
		}
	}


	void veer() :
	{
	}
	{
		(< RIGHT > {world.turnRight(); this.salida = this.salida + "\nCommand: Veer right ";})
	|	(< AROUND > {world.turnRight(); world.turnRight(); this.salida = this.salida + "\nCommand: Veer around ";})
	|	(< LEFT > {world.turnRight(); world.turnRight(); world.turnRight(); this.salida = this.salida + "\nCommand: Veer left ";})
	}


	void look() :
	{
	}
	{
		(< NORTH > {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look north ";
		})
	|	(< SOUTH > {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look south ";
		})
	|	(< EAST > {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look east ";
		})
	|	(< WEST > {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look west ";
		})
	}


	void dMove() :
	{
		Integer n;
	}
	{ n = numVar() ","
		(( < FRONT > {
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Move to the front, face original direction ";
		})
	|	( < RIGHT > {
			world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the right, face original direction ";
		})
	|	( < BACK > {
			world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the back, face original direction ";
		})
	|	( < LEFT > {
			world.turnRight(); world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the left, face original direction ";
		}))
	}


	void oMove() :
	{
		Integer n;
	}
	{ n = numVar() "," 
		((< NORTH > {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face north, move steps";
		})
	|	(< SOUTH > {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face south, move steps";
		})
	|	(< EAST > {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face east, move steps";
		})
	|	(< WEST > {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face west, move steps";
		}))
	}


	boolean isFacing():
	{
		boolean bool;
	}
	{
		((< NORTH > {
			bool=world.facingNorth();})
	|	(< SOUTH > {
			bool=world.facingSouth();})
	|	(< EAST > {
			bool=world.facingEast();})
	|	(< WEST > {
			bool=world.facingWest();})) { return bool; }
	}


	boolean isValid():
	{
		Integer n;
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
		boolean outOfBounds;
	}
	{ 
		((< STEP > ","  n  = numVar() { // p
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if path is blocked*/
				if(world.facingNorth())
					bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
				else if(world.facingSouth()) 
					bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
				else if(world.facingEast())
					bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
				else if(world.facingWest())
					bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
			}
		})
	|	(< JUMP > ","  n  = numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if final position is blocked*/
				if(world.facingNorth())
					bool = !world.isBlocked(new Point(posX, posY-pasos));
				else if(world.facingSouth()) 
					bool = !world.isBlocked(new Point(posX, posY+pasos));
				else if(world.facingEast())
					bool = !world.isBlocked(new Point(posX, posX+pasos));
				else if(world.facingWest())
					bool = !world.isBlocked(new Point(posX, posX-pasos));
			}
		})
	|	(< GRAB > ","  n  = numVar() {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		})
	|	(< POP > ","  n  = numVar() {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}		})
	|	(< PICK > ","  n  = numVar() { /* Equivalent to 'grab' */
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		}) 
	|	(< FREE > ","  n  = numVar() {
			if ((n < 0) || (world.getMyBalloons()< n)) {
				bool = false;
			}
		})
	|	(< DROP > ","  n  = numVar() {
			if ((n < 0) || (n > world.freeSpacesForChips()) || (world.getMyChips()< n)) {
				bool = false;
			}
		})) { return bool; }
	}


	boolean canMove():
	{
		Integer n;
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
	}
	{
		((< NORTH > ","  n=numVar() { // p
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX, posY-pasos)) {
				bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
			} else {
				bool = false;
			}
		})
	|	(< SOUTH > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX, posY+pasos)) {
				bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
			} else {
				bool = false;
			}
		})
	|	(< EAST > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX+pasos, posY)) {
				bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
			} else {
				bool = false;
			}
		})
	|	(< WEST > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX-pasos, posY)) {
				bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
			} else {
				bool = false;
			}
		})) { return bool; }
	}


JAVACODE
	private boolean isOnBoard(int x, int y) {
		boolean bool = true;
		if (x<1 || x >8 || y<1 || y >8) { 
			bool = false;
		}
		return bool;
	}


	boolean not():
	{
		boolean bool;
	}
	{
		bool=condition() {return !bool;}
	}


	void checkSintaxInstrBlock():
	{
	}
	{
		"{" checkSintaxInstr() (  ";" checkSintaxInstr() )* "}"
	}


	void procInstrBlock():
	{
	}
	{
		"{" checkSintaxInstr() (  ";" checkSintaxInstr() )* "}"
	}


	void repeatInstrBlock(Integer n):
	{
		ArrayList<String> instrs = new ArrayList<String>();
		ArrayList<String> instr = new ArrayList<String>();
	}
	{
		"{" instr = saveInstr() {instrs.addAll(instr);} ( ";" instr = saveInstr() {instrs.addAll(instr);} )* "}" {
			for(Integer i = 0; i < n; i++) {
				manuallyExecuteInstrs(instrs);
			}
		}
	}

	void whileInstrBlock(ArrayList<String> cond):
	{
		ArrayList<String> instrs = new ArrayList<String>();
		ArrayList<String> instr = new ArrayList<String>();
		boolean bool = false;
	}
	{
		"{" instr = saveInstr() {instrs.addAll(instr);} (  ";" instr = saveInstr() {instrs.addAll(instr);} )* "}"
		{
			bool = manuallyEvaluateCond(cond);
			while(bool) {
				manuallyExecuteInstrs(instrs);
				bool = manuallyEvaluateCond(cond);
			}
		}
	}


JAVACODE
	private void instrWhile(boolean bool) {
		if (bool) {
			instr();
		} else {
			checkSintaxInstr();
		}
	}


JAVACODE
	private void manuallyExecuteInstrs(ArrayList<String> oInstrs) {
		ArrayList<String> instrs = (ArrayList<String>) oInstrs.clone();
		Integer n, m;
		String dir, insName;
		for (Integer i = 0; i < instrs.size(); i++) {
			insName = instrs.get(i).trim();
			if (insName.equals("step")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.moveForward(n, false);
				i++;
				this.salida = this.salida + "\nCommand: Move steps forward ";
			} else if (insName.equals("jump")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.moveForward(n, true);
				i++;
				this.salida = this.salida + "\nCommand: Jump steps forward ";
			} else if (insName.equals("drop")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.putChips(n);
				i++;
				this.salida = this.salida + "\nCommand: Drop chips from its position ";
			} else if (insName.equals("grab")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.grabBalloons(n);
				i++;
				this.salida = this.salida + "\nCommand: Grab balloons from its position ";
			} else if (insName.equals("get")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.pickChips(n);
				i++;
				this.salida = this.salida + "\nCommand: Get chips from its position ";
			} else if (insName.equals("free")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.putBalloons(n);
				i++;
				this.salida = this.salida + "\nCommand: Put balloons from its position ";
			} else if (insName.equals("pop")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.popBalloons(n);
				i++;
				this.salida = this.salida + "\nCommand: Pop balloons from its position ";
			} else if (insName.equals("jumpTo")) {
				n = Integer.valueOf(instrs.get(i+1));
				m = Integer.valueOf(instrs.get(i+2));
				world.setPostion(n, m);
				i += 2;
				this.salida = this.salida + "\nCommand: Jump to position ";
			} else if (insName.equals("veer")) {
				dir = instrs.get(i+1);
				manualVeer(dir);
				i++;
			} else if (insName.equals("look")) {
				dir = instrs.get(i+1);
				manualLook(dir);
				i++;
			} else if (insName.equals("Dmove")) {
				n = Integer.valueOf(instrs.get(i+1));
				dir = instrs.get(i+2);
				manualDMove(n, dir);
				i+=2;
			} else if (insName.equals("Omove")) {
				n = Integer.valueOf(instrs.get(i+1));
				dir = instrs.get(i+2);
				manualOMove(n, dir);
				i+=2;
			} else if (insName.equals("if")) {
				ArrayList<String> cond = new ArrayList<String >();
				ArrayList<String> doIfTrue = new ArrayList<String >();
				ArrayList<String> doIfFalse = new ArrayList<String >();
				boolean bool;
				i++;
				while (!instrs.get(i).equals("fincond")) {
					cond.add(instrs.get(i));
					i++;
				}
				i++;
				bool = manuallyEvaluateCond(cond);
				boolean meterAdoIfTrue = true;
				while (!instrs.get(i).equals("fi")) {
					if (instrs.get(i).equals("else")) {
						meterAdoIfTrue = false;
					} else {
						if (meterAdoIfTrue) {
							doIfTrue.add(instrs.get(i));
						} else {
							doIfFalse.add(instrs.get(i));
						}
					}
					i++;
				}
				if (bool) {
					manuallyExecuteInstrs(doIfTrue);
				} else {
					manuallyExecuteInstrs(doIfFalse);
				}
			} else if (this.declaredVars.contains(insName)) {
				n = Integer.valueOf(instrs.get(i+1));
				this.vars.put(insName, n);
				this.salida = this.salida + "\nCommand: Variable assignment";
				i++;
			}
		}
	}


JAVACODE
	private boolean manuallyEvaluateCond(ArrayList<String> cond) {
		boolean bool = true;
		String cmd;
		String dir;
		String condName;
		Integer n;
		for (Integer i = 0; i < cond.size(); i++) {
			condName = cond.get(i).trim();
			if (condName.equals("isfacing")) {
				dir = cond.get(i+1);
				bool = manualIsFacing(dir);
				i++;
			} else if (condName.equals("isValid")) {
				cmd = cond.get(i+1);
				n = Integer.valueOf(cond.get(i+2));
				bool = manualIsValid(cmd, n);
				i+=2;
			} else if (condName.equals("canMove")) {
				dir = cond.get(i+1);
				n = Integer.valueOf(cond.get(i+2));
				bool = manualCanMove(dir, n);
				i+=2;
			} else if (condName.equals("not")) {
				ArrayList<String> condNot = new ArrayList<String >();
				i++;
				int parar = cond.indexOf("fincond");
				while (i < parar) {
					condNot.add(cond.get(i));
					i++;
				}
				bool = manuallyEvaluateCond(condNot);
			}
		}
		return bool;
	}

JAVACODE
	boolean manualIsFacing(String dir) {
		boolean bool = true;
		if (dir.equals("north")) {
			bool=world.facingNorth();
		} else if (dir.equals("south")) {
			bool=world.facingSouth();
		} else if (dir.equals("east")) {
			bool=world.facingEast();
		} else if (dir.equals("west")) {
			bool=world.facingWest();
		}
		return bool;
	}


JAVACODE
	boolean manualIsValid(String cmd, Integer n) {
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
		boolean outOfBounds;

		if (cmd.equals("step")) {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if path is blocked*/
				if(world.facingNorth())
					bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
				else if(world.facingSouth()) 
					bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
				else if(world.facingEast())
					bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
				else if(world.facingWest())
					bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
			}
		} else if (cmd.equals("jump")) {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if final position is blocked*/
				if(world.facingNorth())
					bool = !world.isBlocked(new Point(posX, posY-pasos));
				else if(world.facingSouth()) 
					bool = !world.isBlocked(new Point(posX, posY+pasos));
				else if(world.facingEast())
					bool = !world.isBlocked(new Point(posX, posX+pasos));
				else if(world.facingWest())
					bool = !world.isBlocked(new Point(posX, posX-pasos));
			}
		} else if (cmd.equals("grab")) {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		} else if (cmd.equals("pop")) {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		} else if (cmd.equals("pick")) {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		} else if (cmd.equals("free")) {
			if ((n < 0) || (world.getMyBalloons()< n)) {
				bool = false;
			}
		} else if (cmd.equals("drop")) {
			if ((n < 0) || (n > world.freeSpacesForChips()) || (world.getMyChips()< n)) {
				bool = false;
			}
		}
		return bool;
	}


JAVACODE
	boolean manualCanMove (String dir, Integer n) {
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
		pasos = n;
		if (dir.equals("north")) {
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX, posY-pasos)) {
				bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
			} else {
				bool = false;
			}
		} else if (dir.equals("south")) {
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX, posY+pasos)) {
				bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
			} else {
				bool = false;
			}
		} else if (dir.equals("east")) {
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX+pasos, posY)) {
				bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
			} else {
				bool = false;
			}
		} else if (dir.equals("west")) {
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			if (isOnBoard(posX-pasos, posY)) {
				bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
			} else {
				bool = false;
			}
		}
		return bool;
	}


JAVACODE
	private void manualVeer(String dir) {
		if (dir.equals("right")) {
			world.turnRight();
			this.salida = this.salida + "\nCommand: Veer right ";
		} else if (dir.equals("around")) { 
			world.turnRight();
			world.turnRight();
			this.salida = this.salida + "\nCommand: Veer around ";
		} else if (dir.equals("left")) {
			world.turnRight();
			world.turnRight();
			world.turnRight();
			this.salida = this.salida + "\nCommand: Veer left ";
		}
	}


JAVACODE
	private void manualLook(String dir)	{
		if (dir.equals("north")) {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look north ";
		} else if (dir.equals("south")) {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look south ";
		} else if (dir.equals("east")) {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look east ";
		} else if (dir.equals("west")) {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look west ";
		}
	}



JAVACODE
	private void manualDMove(Integer n, String dir) { 
		if (dir.equals("front")) {
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Move to the front, face original direction ";
		} else if (dir.equals("right")) {
			world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the right, face original direction ";
		} else if (dir.equals("back")) {
			world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the back, face original direction ";
		} else if (dir.equals("left")) {
			world.turnRight(); world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the left, face original direction ";
		}
	}


JAVACODE
	private void manualOMove(Integer n, String dir) {
		if (dir.equals("north")) {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face north, move steps";
		} else if (dir.equals("south")) {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face south, move steps";
		} else if (dir.equals("east")) {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face east, move steps";
		} else if (dir.equals("west")) {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face west, move steps";
		}
	}


	ArrayList<String> saveInstr():
	{
		ArrayList<String> instr = new ArrayList<String>();
	}
	{
		(LOOKAHEAD(2) instr = saveCmd()
	|	instr = saveCtrlStruct()
	|	instr = saveProcCall()) { return instr; }
	}


	ArrayList<String> saveCmd():
	{
		ArrayList<String> cmd = new ArrayList<String>();
		ArrayList<String> l = new ArrayList<String>();
		int n, m;
	}
	{
		(( < NAME > { cmd.add(token.image); } ":=" n = num() { cmd.add(Integer.toString(n)); } )
	|	(< STEP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")" )
	|	(< JUMP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< JUMPTO > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } "," m = numVar() { cmd.add(Integer.toString(m)); } ")")
	|	(< VEER > { cmd.add(token.image); } "(" l = saveVeer() { cmd.addAll(l); } ")")
	|	(< LOOK > { cmd.add(token.image); } "(" l = saveLook() { cmd.addAll(l); } ")")
	|	(< DROP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< GRAB > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< GET > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< FREE > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< POP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< DMOVE > { cmd.add(token.image); } "(" l = saveDMove() { cmd.addAll(l); } ")")
	|	(< OMOVE > { cmd.add(token.image); } "(" l = saveOMove() { cmd.addAll(l); } ")")) { return cmd; }
	}


	ArrayList<String> saveVeer() :
	{
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		((< RIGHT > { l.add(token.image); } )
	|	(< AROUND > { l.add(token.image); })
	|	(< LEFT > { l.add(token.image); })) { return l; }
	}


	ArrayList<String> saveLook() :
	{
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		((< NORTH > { l.add(token.image); })
	|	(< SOUTH > { l.add(token.image); })
	|	(< EAST > { l.add(token.image); })
	|	(< WEST > { l.add(token.image); } )) { return l; }
	}


	ArrayList<String> saveDMove() :
	{
		Integer n;
		ArrayList<String> l = new ArrayList<String>();
	}
	{ (n = numVar() { l.add(Integer.toString(n)); } ","
		(( < FRONT > { l.add(token.image); })
	|	( < RIGHT > { l.add(token.image); })
	|	( < BACK > { l.add(token.image); })
	|	( < LEFT > { l.add(token.image); }))) { return l; }
	}


	ArrayList<String> saveOMove() :
	{
		Integer n;
		ArrayList<String> l = new ArrayList<String>();
	}
	{ (n = numVar() { l.add(Integer.toString(n)); } "," 
		((< NORTH > { l.add(token.image); })
	|	(< SOUTH > { l.add(token.image); })
	|	(< EAST > { l.add(token.image); })
	|	(< WEST > { l.add(token.image); }))) { return l; }
	}


	ArrayList<String> saveCtrlStruct():
	{
		ArrayList<String> ctrlStruct = new ArrayList<String>();
	}
	{
		(ctrlStruct = saveIfFi()
	|	ctrlStruct = saveWhileDoOd()
	|	ctrlStruct = saveRepeatTimes()) { return ctrlStruct;}
	}


	ArrayList<String> saveIfFi():
	{
		boolean bool;
		ArrayList<String> instrs = new ArrayList<String>();
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		(< IF > { instrs.add(token.image); } "(" l = saveCond() { instrs.addAll(l); } ")"
			"{" l = saveInstr() { instrs.addAll(l); } ( ";" l = saveInstr() { instrs.addAll(l); } )* "}"
		[< ELSE > { instrs.add(token.image); }
			"{" l = saveInstr() { instrs.addAll(l); } ( ";" l = saveInstr() { instrs.addAll(l); } )* "}"
		] < FI > { instrs.add(token.image); }) {
		this.salida = this.salida + "\n'if' conditional control structure";
		return instrs;
		}
	}


JAVACODE
	private ArrayList<String> saveInstrIf(boolean bool) {
		ArrayList<String> l = new ArrayList<String>();
		if (bool) {
			l = saveInstr();
		} else {
			checkSintaxInstr();
		}
		return l;
	}


	ArrayList<String> saveWhileDoOd():
	{
		boolean bool;
		ArrayList<String> l = new ArrayList<String>();
		ArrayList<String> ins = new ArrayList<String>();
	}
	{
		< WHILE > "(" l = saveCond() { ins.addAll(l); } ")" < DO > /* TODO: saveWhileInstrBlock(bool) */ < OD > {
			this.salida = this.salida + "\n'while' loop control structure";
			return ins;
			}
	}


	ArrayList<String> saveCond():
	{
		ArrayList<String> cond = new ArrayList<String>();
		ArrayList<String> l = new ArrayList<String>();
		Integer n;
	}
	{
		((< ISFACING > { cond.add(token.image); } "(" (
			< NORTH >| < SOUTH >|< EAST >|< WEST >) { cond.add(token.image); } ")")
	|	(< ISVALID > { cond.add(token.image); } "(" (
			< STEP >|< JUMP >|< GRAB >|< POP >|< PICK >|< FREE >|< DROP >
			) { cond.add(token.image); }
		 "," n = numVar() { cond.add(Integer.toString(n)); } ")")
	|	(< CANMOVE > { cond.add(token.image); } "(" (
			< NORTH >| < SOUTH >|< EAST >|< WEST >
			) { cond.add(token.image); }
			"," n = numVar() { cond.add(Integer.toString(n)); } ")")
	|	(< NOT > { cond.add(token.image); } "(" l = saveCond() {cond.addAll(l); } ")")
	) { cond.add("fincond"); return cond;}
	}



	ArrayList<String> saveRepeatTimes():
	{
		Integer n;
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		( < REPEATTIMES > n = numVar() ) /* TODO: saveRepeatInstrBlock(n) */ ( < PER > ) {
			this.salida = this.salida + "\n'repeatTimes' loop control structure";
			return l;
		}
	}


	ArrayList<String> saveProcCall():
	{
		String name;
		ArrayList<String> rParams = new ArrayList<String>();
	}
	{
		(name = name() "(") [rParams = params()] ")" {
			if (!procsNames.contains(name)) {
				throw new Error("Tried to call undeclared procedure");
			}
			if (rParams.size() != procsParams.get(name).size()) {
				throw new Error("Incorrect number of parameters for "+name+" procedure");
			}
			// TODO: Guardar el llamado del procedimiento
		}
	}


	void checkSintaxInstr():
	{
	}
	{
		LOOKAHEAD(2) checkSintaxCmd()
	|	checkSintaxCtrlStruct()
	|	checkSintaxProcCall()
	}


	void checkSintaxCmd():
	{
	}
	{
		( < NAME > ":=" < NUM >)
	|	(< STEP >  "(" numVar() ")" )
	|	(< JUMP >  "(" numVar() ")")
	|	(< JUMPTO >  "(" numVar() "," numVar() ")")
	|	(< VEER >  "(" (< RIGHT >|< AROUND >|< LEFT >) ")")
	|	(< LOOK >  "(" (< NORTH >|< SOUTH >|< EAST >|< WEST >) ")")
	|	(< DROP >  "(" numVar() ")")
	|	(< GRAB >  "(" numVar() ")")
	|	(< GET >  "(" numVar() ")")
	|	(< FREE >  "(" numVar() ")")
	|	(< POP >  "(" numVar() ")")
	|	(< DMOVE >  "(" numVar() "," (< FRONT >|< RIGHT >|< LEFT >|< BACK >) ")")
	|	(< OMOVE >  "(" numVar() "," (< NORTH >|< SOUTH >|< EAST >|< WEST >) ")")
	}


	void checkSintaxCtrlStruct():
	{
	}
	{
		checkSintaxifFi()
	|	checkSintaxwhileDoOd()
	|	checkSintaxrepeatTimes()
	}


	void checkSintaxifFi():
	{
		boolean bool;
	}
	{
		(< IF > "(" condition() ")" checkSintaxInstrBlock()
		[< ELSE > checkSintaxInstrBlock()	] < FI >) 
	}


	void checkSintaxwhileDoOd():
	{
	}
	{
		< WHILE > "(" condition() ")" < DO > checkSintaxInstrBlock() < OD >
	}


	void checkSintaxProcCall():
	{
	}
	{
		(name = name() "(") [rParams = params()] ")" {
			if (!procsNames.contains(name)) {
				throw new Error("Tried to call undeclared procedure");
			}
			if (rParams.size() != procsParams.get(name).size()) {
				throw new Error("Incorrect number of parameters for "+name+" procedure");
			}
		}
	}


	void checkSintaxrepeatTimes():
	{
	}
	{
		< REPEATTIMES > numVar() checkSintaxInstrBlock() < PER > 
	}


	String name():
	{
	}
	{
		< NAME > { return token.image; }
	}


	/**
	 * Unsigned decimal number
	 * @return the corresponding value of the string
	 * @error  corresponding value is too large
	 */

	Integer num() throws Error:
	{
		int total_;
		Integer total;
	}
	{
		<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
			return total;
		}
	}


	Integer numVar() throws Error:
	{
		int total_;
		Integer total;
	}
	{
		((<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
		})
	|	( (< NAME >) {
			if (vars.containsKey(token.image)) {
				total_ = vars.get(token.image);
				total = Integer.valueOf(total_);
			} else {
				throw new Error("Tried to use undeclared variable");
			}
		 })) { return total; }
	}


	Integer numVarParam(Hashtable<String, Integer> procParams) throws Error:
	{
		int total_;
		Integer total;
	}
	{
		((<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
		})
	|	(< NAME > {
			if (procParams.containsKey(token.image)) {
				total = procParams.get(token.image);
			} 
			else if (vars.containsKey(token.image)) {
				total = vars.get(token.image);
			} else {
				throw new Error("Tried to use unexsiting parameter or undeclared variable");
			}
		 })) { return total; }
	}
	

