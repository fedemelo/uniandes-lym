/*
Project 1
@authors: Federico Melo Barrero, f.melo, 202021525
		  Germán Alberto Rojas Cetina, g.rojasc, 202013415

Please rename file to 'Robot.jj' before using.
*/


options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
}


PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
 
import java.awt.Point;
import java.io.*;
import java.util.*;

@SuppressWarnings("serial")
public class Robot 
{
	private RobotWorldDec world;


	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}


	private String salida = "";

	private ArrayList<String> declaredVars = new ArrayList<String>();
	private Hashtable<String, Integer> vars = new Hashtable<String, Integer>();
	private ArrayList<String> procsNames = new ArrayList<String>();
	private Hashtable<String, ArrayList<String>> procsParams = new Hashtable<String, ArrayList<String>>();
	private Hashtable<String, ArrayList<String>> procsInstrs = new Hashtable<String, ArrayList<String>>();
}

PARSER_END(Robot)


SKIP:
{
		" "
	|	"\r"
	|	"\t"
	|	"\n"
}


/* Commands */
TOKEN: 
{
		< STEP: "step" >
	|	< JUMP: "jump" >
	|	< JUMPTO: "jumpTo" >
	|	< VEER: "veer" >
	|	< LOOK: "look" >
	|	< DROP: "drop" >
	|	< GRAB: "grab" >
	|	< GET: "get" >
	|	< FREE: "free" >
	|	< POP: "pop" >
	| 	< DMOVE:  "Dmove" >
	|	< OMOVE:  "Omove" >
}


/* Control structures */
TOKEN :
{
		< IF: "if" >
	|	< FI: "fi" >
	|	< ELSE: "else" >
	| 	< WHILE: "while" >
	|	< DO: "do" >
	| 	< OD: "od" >
	|	< REPEATTIMES: "repeatTimes" >
	|	< PER : "per" >
}


/* Conditions */
TOKEN :
{
		< ISFACING : "isfacing" >
	| 	< ISVALID: "isValid" >
	| 	< CANMOVE: "canMove" >
	| 	< NOT: "not" >
	|	< PICK:  "pick" > // For isValid condition
}


/* Cardinal directions */
TOKEN :
{
	 	< NORTH: "north" >
	| 	< SOUTH: "south" >
	| 	< EAST: "east" >
	| 	< WEST: "west" >
}


/* Directions */
TOKEN :
{
		< AROUND: "around" >
	| 	< RIGHT: "right" >
	| 	< LEFT: "left" >
	| 	< FRONT: "front" >
	| 	< BACK: "back" >
}


/* Keywords */
TOKEN :
{
		< PROG: "PROG" >
	|	< GORP: "GORP" >
	|	< VAR: "VAR" >
	|	< PROC: "PROC" >
	|	< CORP: "CORP" >
}


/* Name */
TOKEN :
{
		< NAME: <LETTER>(["a"-"z","A"-"Z","0"-"9"])* >
	|  	< #LETTER: ["a"-"z","A"-"Z"] >
}

/* Number */
TOKEN :
{
		< NUM: (<DIGIT>)+ >
	|  	< #DIGIT: ["0"-"9"] >
}


	boolean command(Console sistema):
	{
	}
	{
		( < PROG > [varDecl()] (procDef())* instrBlock() < GORP >) {
		    try {
	    		Thread.sleep(900);
	    	} catch (InterruptedException e) {
	    		System.err.format("IOException: %s%n", e);
	    	}
			sistema.printOutput(salida);
			return true;
		}
    	| <EOF> {return false;}
	}


	void varDecl():
	{
		String name;
	}
	{
		((< VAR > name=name()) {
			this.declaredVars.add(name);
		} ( LOOKAHEAD(2) "," (name=name()) {
			if (this.declaredVars.contains(name)) {
				throw new Error("Repeated variable name: "+name+ " in variable declaration");
			} else {
				this.declaredVars.add(name);
			}
		} )* ";" ) {
			this.salida = this.salida + "Variable declaration";
		}
	}


	void procDef():
	{
		String name;
		ArrayList<String> localVars = new ArrayList<String>();
		ArrayList<String> instructions = new ArrayList<String>();
	}
	{
		( < PROC > name=name() "(" [localVars=params()] ")" {
			if (procsNames.contains(name)) {
				throw new Error ("Procedure with name "+name+" has already been declared");
			}
			procsNames.add(name);
			procsParams.put(name, localVars);
			} "{" (
				/*instrProc(name, localVars)*/
					(";" /*instrProc(name, localVars) */ )*  )
			"}" <  CORP > )
			{ this.salida = this.salida + "Procedure definition"; }
	}


	ArrayList<String> params():
	{
		ArrayList<String> localVars = new ArrayList<String>();
		String name;
	}
	{
		((name=name()) {
			localVars.add(name);
		} ( LOOKAHEAD(2) "," (name=name()) {
			if (localVars.contains(name)) {
				throw new Error("Repeated parameter name: "+name);
			} else {
				localVars.add(name);
			}
		} )*) { return localVars; }
	}


//	void instrProc(String name, ArrayList<String> localVars):
//	{
//	}
//	{
//	}


	void instrBlock():
	{
	}
	{
		"{" instr() ( LOOKAHEAD(2) ";" instr() )* "}"
	}


	void instr():
	{
	}
	{
		LOOKAHEAD(2) cmd()
	|	ctrlStruct()
	|	procCall()
	}


	void cmd():
	{
		String name;
		Integer n, m;
	}
	{
		((name=name() ":=" n = num()) {
			if (declaredVars.contains(name)) {
				vars.put(name, n);
			} else {
				throw new Error("Tried to assign to undeclared variable "+name);
			}
			this.salida = this.salida + "Command: Variable assignment";
		})
	|	(< STEP >  "(" n = numVar() ")" {world.moveForward(n, false); this.salida = this.salida + "Command: Move steps forward ";})
	|	(< JUMP >  "(" n  = numVar() ")" {world.moveForward(n, true); this.salida = this.salida + "Command: Jump steps forward ";})
	|	(< JUMPTO >  "(" n  = numVar() "," m = numVar()")" {world.setPostion(n,m); this.salida = this.salida + "Command: Jump to position ";})
	|	(< VEER >  "(" veer() ")")
	|	(< LOOK >  "(" look() ")")
	|	(< DROP >  "(" n  = numVar() ")" {world.putChips(n); this.salida = this.salida + "Command: Drop chips from its position ";})
	|	(< GRAB >  "(" n  = numVar() ")" {world.grabBalloons(n); this.salida = this.salida + "Command: Grab balloons from its position ";})
	|	(< GET >  "(" n  = numVar() ")" {world.pickChips(n); this.salida = this.salida + "Command: Get chips from its position ";})
	|	(< FREE >  "(" n  = numVar() ")" {world.putBalloons(n); this.salida = this.salida + "Command: Put balloons from its position ";})
	|	(< POP >  "(" n  = numVar() ")" {world.popBalloons(n); this.salida = this.salida + "Command: Pop balloons from its position ";})
	|	(< DMOVE >  "(" dMove() ")")
	|	(< OMOVE >  "(" oMove() ")")
	}


	void ctrlStruct():
	{
	}
	{
		ifFi()
	|	whileDoOd()
	|	repeatTimes()
	}


	void ifFi():
	{
		boolean bool;
	}
	{
		(< IF > "(" bool=condition() ")" instrBlockTrue(bool) [< ELSE > instrBlockFalse(bool)] < FI >) {
			this.salida = this.salida + "'if' conditional control structure";
			}
	}


JAVACODE
	private void instrBlockTrue(boolean bool) {
		if (bool) {
			instrBlock();
		} else {
			token = getNextToken();
		}
	}


JAVACODE
	private void instrBlockFalse(boolean bool) {
		if (!bool) {
			instrBlock();
		} else {
			token = getNextToken();
		}
	}


	void whileDoOd():
	{
		boolean bool;
	}
	{
		< WHILE > "(" bool=condition() ")" < DO > /*instrBlockWhile(bool)*/ < OD > {
			/*TODO : Lógica Java while. Implementar instrBlockWhile*/
			this.salida = this.salida + "'while' loop control structure";
			}
	}


	void repeatTimes():
	{
		Integer n;
	}
	{
		( < REPEATTIMES > n  = numVar() ) {
			for (int i=0; i<n; i++) {
				instrBlock();
			}
		} ( < PER > ) {
			this.salida = this.salida + "'repeatTimes' loop control structure";
		}
	}


	boolean condition():
	{
		boolean bool;
	}
	{
		(< ISFACING >  "(" bool=isFacing() ")"
	|	< ISVALID >  "(" bool=isValid() ")"
	|	< CANMOVE >  "(" bool=canMove() ")"
	|	< NOT >  "(" bool=not() ")") {return bool;}
	}


	void procCall():
	{
		String name;
		ArrayList<String> rParams = new ArrayList<String>();
	}
	{
		(name = name() "(") [rParams = params()] ")" {
			if (!procsNames.contains(name)) {
				throw new Error("Tried to call undeclared procedure");
			}
			if (rParams.size() != procsParams.get(name).size()) {
				throw new Error("Incorrect number of parameters for "+name+" procedure");
			}
			for (String instr: procsInstrs.get(name)) {
				
			}
		}
	}


	void veer() :
	{
	}
	{
		(< RIGHT > {world.turnRight(); this.salida = this.salida + "Command: Veer right ";})
	|	(< AROUND > {world.turnRight(); world.turnRight(); this.salida = this.salida + "Command: Veer around ";})
	|	(< LEFT > {world.turnRight(); world.turnRight(); world.turnRight(); this.salida = this.salida + "Command: Veer left ";})
	}


	void look() :
	{
	}
	{
		(< NORTH > {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "Command: Look north ";
		})
	|	(< SOUTH > {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "Command: Look south ";
		})
	|	(< EAST > {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "Command: Look east ";
		})
	|	(< WEST > {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "Command: Look west ";
		})
	}


	void dMove() :
	{
		Integer n;
	}
	{ n = numVar() ","
		(( < FRONT > {
			world.moveForward(n, false);
			this.salida = this.salida + "Command: Move to the front, face original direction ";
		})
	|	( < RIGHT > {
			world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight(); world.turnRight();
			this.salida = this.salida + "Command: Move to the right, face original direction ";
		})
	|	( < BACK > {
			world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight();
			this.salida = this.salida + "Command: Move to the back, face original direction ";
		})
	|	( < LEFT > {
			world.turnRight(); world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight();
			this.salida = this.salida + "Command: Move to the left, face original direction ";
		}))
	}


	void oMove() :
	{
		Integer n;
	}
	{ n = numVar() "," 
		((< NORTH > {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "Command: Face north, move steps";
		})
	|	(< SOUTH > {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "Command: Face south, move steps";
		})
	|	(< EAST > {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "Command: Face east, move steps";
		})
	|	(< WEST > {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "Command: Face west, move steps";
		}))
	}


	boolean isFacing():
	{
		boolean bool;
	}
	{
		((< NORTH > {
			bool=world.facingNorth();})
	|	(< SOUTH > {
			bool=world.facingSouth();})
	|	(< EAST > {
			bool=world.facingEast();})
	|	(< WEST > {
			bool=world.facingWest();})) { return bool; }
	}


	boolean isValid():
	{
		Integer n;
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
		boolean outOfBounds;
	}
	{ // TODO: Que n pueda ser param
		((< STEP > ","  n  = numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if path is blocked*/
				if(world.facingNorth())
					bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
				else if(world.facingSouth()) 
					bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
				else if(world.facingEast())
					bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
				else if(world.facingWest())
					bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
			}
		})
	|	(< JUMP > ","  n  = numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if final position is blocked*/
				if(world.facingNorth())
					bool = !world.isBlocked(new Point(posX, posY-pasos));
				else if(world.facingSouth()) 
					bool = !world.isBlocked(new Point(posX, posY+pasos));
				else if(world.facingEast())
					bool = !world.isBlocked(new Point(posX, posX+pasos));
				else if(world.facingWest())
					bool = !world.isBlocked(new Point(posX, posX-pasos));
			}
		})
	|	(< GRAB > ","  n  = numVar() {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		})
	|	(< POP > ","  n  = numVar() {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}		})
	|	(< PICK > ","  n  = numVar() { /* Equivalent to 'grab' */
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		}) 
	|	(< FREE > ","  n  = numVar() {
			if ((n < 0) || (world.getMyBalloons()< n)) {
				bool = false;
			}
		})
	|	(< DROP > ","  n  = numVar() {
			if ((n < 0) || (n > world.freeSpacesForChips()) || (world.getMyChips()< n)) {
				bool = false;
			}
		})) { return bool; }
	}


	boolean canMove():
	{
		Integer n;
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
	}
	{  // TODO: Que pueda ser param
		((< NORTH > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
		})
	|	(< SOUTH > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
		})
	|	(< EAST > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
		})
	|	(< WEST > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
		})) { return bool; }
	}


	boolean not():
	{
		boolean bool;
	}
	{
		bool=condition() {return !bool;}
	}



	String name():
	{
	}
	{
		< NAME > { return token.image; }
	}


	/**
	 * Unsigned decimal number
	 * @return the corresponding value of the string
	 * @error  corresponding value is too large
	 */

	Integer num() throws Error:
	{
		int total_;
		Integer total;
	}
	{
		<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
			return total;
		}
	}


	Integer numVar() throws Error:
	{
		int total_;
		Integer total;
	}
	{
		((<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
		})
	|	( (< NAME >) {
			if (vars.containsKey(token.image)) {
				total_ = vars.get(token.image);
				total = Integer.valueOf(total_);
			} else {
				throw new Error("Tried to use undeclared variable");
			}
		 })) { return total; }
	}


	Integer numVarParam(Hashtable<String, Integer> procParams) throws Error:
	{
		int total_;
		Integer total;
	}
	{
		((<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
		})
	|	(< NAME > {
			if (procParams.containsKey(token.image)) {
				total = procParams.get(token.image);
			} 
			else if (vars.containsKey(token.image)) {
				total = vars.get(token.image);
			} else {
				throw new Error("Tried to use unexsiting parameter or undeclared variable");
			}
		 })) { return total; }
	}
	

