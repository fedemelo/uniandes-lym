/*
Project 1
@authors: Federico Melo Barrero, f.melo, 202021525
		  Germ√°n Alberto Rojas Cetina, g.rojasc, 202013415

Please rename file to 'Robot.jj' before using.
*/


options 
{
	LOOKAHEAD=1; 
	IGNORE_CASE=true;
	STATIC = false;
}


PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;

import java.awt.Point;
import java.io.*;
import java.util.*;

@SuppressWarnings("serial")
public class Robot 
{
	private RobotWorldDec world;


	void setWorld(RobotWorld w) {
		world = (RobotWorldDec) w;	
	}


	private String salida = new String();

	private ArrayList<String> declaredVars = new ArrayList<String>();
	private Hashtable<String, Integer> vars = new Hashtable<String, Integer>();
	private ArrayList<String> procsNames = new ArrayList<String>();
	private Hashtable<String, ArrayList<String>> procsParams = new Hashtable<String, ArrayList<String>>();
	private Hashtable<String, ArrayList<String>> procsInstrs = new Hashtable<String, ArrayList<String>>();
}

PARSER_END(Robot)


SKIP:
{
		" "
	|	"\r"
	|	"\t"
	|	"\n"
}


/* Commands */
TOKEN: 
{
		< STEP: "step" >
	|	< JUMP: "jump" >
	|	< JUMPTO: "jumpTo" >
	|	< VEER: "veer" >
	|	< LOOK: "look" >
	|	< DROP: "drop" >
	|	< GRAB: "grab" >
	|	< GET: "get" >
	|	< FREE: "free" >
	|	< POP: "pop" >
	| 	< DMOVE:  "Dmove" >
	|	< OMOVE:  "Omove" >
}


/* Control structures */
TOKEN :
{
		< IF: "if" >
	|	< FI: "fi" >
	|	< ELSE: "else" >
	| 	< WHILE: "while" >
	|	< DO: "do" >
	| 	< OD: "od" >
	|	< REPEATTIMES: "repeatTimes" >
	|	< PER : "per" >
}


/* Conditions */
TOKEN :
{
		< ISFACING : "isfacing" >
	| 	< ISVALID: "isValid" >
	| 	< CANMOVE: "canMove" >
	| 	< NOT: "not" >
	|	< PICK:  "pick" > // For isValid condition
}


/* Cardinal directions */
TOKEN :
{
	 	< NORTH: "north" >
	| 	< SOUTH: "south" >
	| 	< EAST: "east" >
	| 	< WEST: "west" >
}


/* Directions */
TOKEN :
{
		< AROUND: "around" >
	| 	< RIGHT: "right" >
	| 	< LEFT: "left" >
	| 	< FRONT: "front" >
	| 	< BACK: "back" >
}


/* Keywords */
TOKEN :
{
		< PROG: "PROG" >
	|	< GORP: "GORP" >
	|	< VAR: "VAR" >
	|	< PROC: "PROC" >
	|	< CORP: "CORP" >
}


/* Name */
TOKEN :
{
		< NAME: <LETTER>(["a"-"z","A"-"Z","0"-"9"])* >
	|  	< #LETTER: ["a"-"z","A"-"Z"] >
}

/* Number */
TOKEN :
{
		< NUM: (<DIGIT>)+ >
	|  	< #DIGIT: ["0"-"9"] >
}


	boolean command(Console sistema):
	{
		salida = "";
	}
	{
		( < PROG > [varDecl()] (procDef())* instrBlock() < GORP >) {
		    try {
	    		Thread.sleep(900);
	    	} catch (InterruptedException e) {
	    		System.err.format("IOException: %s%n", e);
	    	}
			sistema.printOutput(salida);
			return true;
		}
    	| <EOF> {return false;}
	}


	void varDecl():
	{
		String name;
	}
	{
		((< VAR > name=name()) {
			this.declaredVars.add(name);
		} ( LOOKAHEAD(2) "," (name=name()) {
			if (this.declaredVars.contains(name)) {
				throw new Error("Repeated variable name: "+name+ " in variable declaration");
			} else {
				this.declaredVars.add(name);
			}
		} )* ";" ) {
			this.salida = this.salida + "\nVariable declaration";
		}
	}


	void procDef():
	{
		String name;
		ArrayList<String> localVars = new ArrayList<String>();
		ArrayList<String> instructions = new ArrayList<String>();
	}
	{
		 (( < PROC > name=name() "(" [localVars=params()] ")"
		 ) {
			if (procsNames.contains(name)) {
				throw new Error ("Procedure with name "+name+" has already been declared");
			}
			procsNames.add(name);
			procsParams.put(name, localVars);
		} ( procInstrBlock() < CORP > ))
		{ this.salida = this.salida + "\nProcedure definition"; }
	}


	ArrayList<String> params():
	{
		ArrayList<String> localVars = new ArrayList<String>();
		String name;
	}
	{
		((name=name()) {
			localVars.add(name);
		} ( LOOKAHEAD(2) "," (name=name()) {
			if (localVars.contains(name)) {
				throw new Error("Repeated parameter name: "+name);
			} else {
				localVars.add(name);
			}
		} )*) { return localVars; }
	}


	void instrBlock():
	{
	}
	{
		"{" instr() ( LOOKAHEAD(2) ";" instr() )* "}"
	}


	void instr():
	{
	}
	{
		LOOKAHEAD(2) cmd()
	|	ctrlStruct()
	|	procCall()
	}


	void cmd():
	{
		String name;
		Integer n, m;
	}
	{
		((name=name() ":=" n = num()) {
			if (declaredVars.contains(name)) {
				vars.put(name, n);
			} else {
				throw new Error("Tried to assign to undeclared variable "+name);
			}
			this.salida = this.salida + "\nCommand: Variable assignment";
		})
	|	(< STEP >  "(" n = numVar() ")" {world.moveForward(n, false); this.salida = this.salida + "\nCommand: Move steps forward ";})
	|	(< JUMP >  "(" n  = numVar() ")" {world.moveForward(n, true); this.salida = this.salida + "\nCommand: Jump steps forward ";})
	|	(< JUMPTO >  "(" n  = numVar() "," m = numVar()")" {world.setPostion(n,m); this.salida = this.salida + "\nCommand: Jump to position ";})
	|	(< VEER >  "(" veer() ")")
	|	(< LOOK >  "(" look() ")")
	|	(< DROP >  "(" n  = numVar() ")" {world.putChips(n); this.salida = this.salida + "\nCommand: Drop chips from its position ";})
	|	(< GRAB >  "(" n  = numVar() ")" {world.grabBalloons(n); this.salida = this.salida + "\nCommand: Grab balloons from its position ";})
	|	(< GET >  "(" n  = numVar() ")" {world.pickChips(n); this.salida = this.salida + "\nCommand: Get chips from its position ";})
	|	(< FREE >  "(" n  = numVar() ")" {world.putBalloons(n); this.salida = this.salida + "\nCommand: Put balloons from its position ";})
	|	(< POP >  "(" n  = numVar() ")" {world.popBalloons(n); this.salida = this.salida + "\nCommand: Pop balloons from its position ";})
	|	(< DMOVE >  "(" dMove() ")")
	|	(< OMOVE >  "(" oMove() ")")
	}


	void ctrlStruct():
	{
	}
	{
		ifFi()
	|	whileDoOd()
	|	repeatTimes()
	}


	void ifFi():
	{
		boolean bool;
	}
	{
		(< IF > "(" bool=condition() ")"
			"{" instrIf(bool) ( ";" instrIf(bool) )* "}"
		[< ELSE > 
			"{" instrIf(!bool) (  ";" instrIf(!bool) )* "}"
		] < FI >) {
		this.salida = this.salida + "\n'if' conditional control structure";
		}
	}


JAVACODE
	private void instrIf(boolean bool) {
		if (bool) {
			instr();
		} else {
			uselessInstr();
		}
	}


	void whileDoOd():
	{
		boolean bool;
	}
	{
		< WHILE > "(" bool=condition() ")" < DO > whileInstrBlock(bool) < OD > {
			this.salida = this.salida + "\n'while' loop control structure";
			}
	}


	void repeatTimes():
	{
		Integer n;
	}
	{
		( < REPEATTIMES > n = numVar() ) repeatInstrBlock(n) ( < PER > ) {
			this.salida = this.salida + "\n'repeatTimes' loop control structure";
		}
	}


	boolean condition():
	{
		boolean bool;
	}
	{
		(< ISFACING >  "(" bool=isFacing() ")"
	|	< ISVALID >  "(" bool=isValid() ")"
	|	< CANMOVE >  "(" bool=canMove() ")"
	|	< NOT >  "(" bool=not() ")") {return bool;}
	}


	void procCall():
	{
		String name;
		ArrayList<String> rParams = new ArrayList<String>();
	}
	{
		(name = name() "(") [rParams = params()] ")" {
			if (!procsNames.contains(name)) {
				throw new Error("Tried to call undeclared procedure");
			}
			if (rParams.size() != procsParams.get(name).size()) {
				throw new Error("Incorrect number of parameters for "+name+" procedure");
			}
			// TODO: Ejecutar el proc llamado
		}
	}


	void veer() :
	{
	}
	{
		(< RIGHT > {world.turnRight(); this.salida = this.salida + "\nCommand: Veer right ";})
	|	(< AROUND > {world.turnRight(); world.turnRight(); this.salida = this.salida + "\nCommand: Veer around ";})
	|	(< LEFT > {world.turnRight(); world.turnRight(); world.turnRight(); this.salida = this.salida + "\nCommand: Veer left ";})
	}


	void look() :
	{
	}
	{
		(< NORTH > {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look north ";
		})
	|	(< SOUTH > {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look south ";
		})
	|	(< EAST > {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look east ";
		})
	|	(< WEST > {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look west ";
		})
	}


	void dMove() :
	{
		Integer n;
	}
	{ n = numVar() ","
		(( < FRONT > {
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Move to the front, face original direction ";
		})
	|	( < RIGHT > {
			world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the right, face original direction ";
		})
	|	( < BACK > {
			world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the back, face original direction ";
		})
	|	( < LEFT > {
			world.turnRight(); world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the left, face original direction ";
		}))
	}


	void oMove() :
	{
		Integer n;
	}
	{ n = numVar() "," 
		((< NORTH > {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face north, move steps";
		})
	|	(< SOUTH > {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face south, move steps";
		})
	|	(< EAST > {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face east, move steps";
		})
	|	(< WEST > {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face west, move steps";
		}))
	}


	boolean isFacing():
	{
		boolean bool;
	}
	{
		((< NORTH > {
			bool=world.facingNorth();})
	|	(< SOUTH > {
			bool=world.facingSouth();})
	|	(< EAST > {
			bool=world.facingEast();})
	|	(< WEST > {
			bool=world.facingWest();})) { return bool; }
	}


	boolean isValid():
	{
		Integer n;
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
		boolean outOfBounds;
	}
	{ 
		((< STEP > ","  n  = numVar() { // p
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if path is blocked*/
				if(world.facingNorth())
					bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
				else if(world.facingSouth()) 
					bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
				else if(world.facingEast())
					bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
				else if(world.facingWest())
					bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
			}
		})
	|	(< JUMP > ","  n  = numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			/* Check if final position is on board */
			outOfBounds = false;
			if(world.facingNorth()) {
				if (posY-pasos < 1) { outOfBounds = true; }
			}	
			else if(world.facingSouth()) {
				if (posY+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingEast()) { 
				if (posX+pasos > 8) { outOfBounds = true; }
			}
			else if(world.facingWest()) { 
				if (posX-pasos < 1) { outOfBounds = true; }
			}
			
			if (outOfBounds) {
				bool = false;
			} else {
				/*Check if final position is blocked*/
				if(world.facingNorth())
					bool = !world.isBlocked(new Point(posX, posY-pasos));
				else if(world.facingSouth()) 
					bool = !world.isBlocked(new Point(posX, posY+pasos));
				else if(world.facingEast())
					bool = !world.isBlocked(new Point(posX, posX+pasos));
				else if(world.facingWest())
					bool = !world.isBlocked(new Point(posX, posX-pasos));
			}
		})
	|	(< GRAB > ","  n  = numVar() {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		})
	|	(< POP > ","  n  = numVar() {
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}		})
	|	(< PICK > ","  n  = numVar() { /* Equivalent to 'grab' */
			if ((n < 0) || (world.countBalloons(world.getPosition()) < n)) {
				bool = false;
			}
		}) 
	|	(< FREE > ","  n  = numVar() {
			if ((n < 0) || (world.getMyBalloons()< n)) {
				bool = false;
			}
		})
	|	(< DROP > ","  n  = numVar() {
			if ((n < 0) || (n > world.freeSpacesForChips()) || (world.getMyChips()< n)) {
				bool = false;
			}
		})) { return bool; }
	}


	boolean canMove():
	{
		Integer n;
		boolean bool = true;
		int pasos;
		int posX;
		int posY;
	}
	{
		((< NORTH > ","  n=numVar() { // p
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posY-pasos, 0);
		})
	|	(< SOUTH > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posY+pasos, 1);
		})
	|	(< EAST > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posX+pasos, 2);
		})
	|	(< WEST > ","  n=numVar() {
			pasos = n;
			posX = (int) world.getPosition().getX();
			posY = (int) world.getPosition().getY();
			bool = !world.blockedInRange(posX, posY, posX-pasos, 3);
		})) { return bool; }
	}


	boolean not():
	{
		boolean bool;
	}
	{
		bool=condition() {return !bool;}
	}


	void uselessInstrBlock():
	{
	}
	{
		"{" uselessInstr() (  ";" uselessInstr() )* "}"
	}


	void procInstrBlock():
	{
	}
	{
		"{" uselessInstr() (  ";" uselessInstr() )* "}"
	}


	void repeatInstrBlock(Integer n):
	{
		ArrayList<String> instrs = new ArrayList<String>();
		ArrayList<String> instr = new ArrayList<String>();
	}
	{
		"{" instr = saveInstr() {instrs.addAll(instr);} ( ";" instr = saveInstr() {instrs.addAll(instr);} )* "}" {
			for(Integer i = 0; i < n; i++) {
				manuallyExecuteInstrs(instrs);
			}
		}
	}

		void whileInstrBlock(boolean bool):
	{
	}
	{
		"{" instrWhile(bool) (  ";" instrWhile(bool) )* "}"
	}


JAVACODE
	private void instrWhile(boolean bool) {
		if (bool) {
			instr();
		} else {
			uselessInstr();
		}
	}


JAVACODE
	private void manuallyExecuteInstrs(ArrayList<String> oInstrs) {
		ArrayList<String> instrs = (ArrayList<String>) oInstrs.clone();
		Integer n, m;
		String dir, insName;
		for (Integer i = 0; i < instrs.size(); i++) {
			insName = instrs.get(i).trim();
			if (insName.equals("step")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.moveForward(n, false);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
				this.salida = this.salida + "\nCommand: Move steps forward ";
			} else if (insName.equals("jump")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.moveForward(n, true);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
				this.salida = this.salida + "\nCommand: Jump steps forward ";
			} else if (insName.equals("drop")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.putChips(n);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
				this.salida = this.salida + "\nCommand: Drop chips from its position ";
			} else if (insName.equals("grab")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.grabBalloons(n);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
				this.salida = this.salida + "\nCommand: Grab balloons from its position ";
			} else if (insName.equals("get")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.pickChips(n);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
				this.salida = this.salida + "\nCommand: Get chips from its position ";
			} else if (insName.equals("free")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.putBalloons(n);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
				this.salida = this.salida + "\nCommand: Put balloons from its position ";
			} else if (insName.equals("pop")) {
				n = Integer.valueOf(instrs.get(i+1));
				world.popBalloons(n);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
				this.salida = this.salida + "\nCommand: Pop balloons from its position ";
			} else if (insName.equals("jumpTo")) {
				this.salida += " entro!!!";
				n = Integer.valueOf(instrs.get(i+1));
				m = Integer.valueOf(instrs.get(i+2));
				world.setPostion(n, m);
				instrs.remove(i);
				instrs.remove(i+1);
				instrs.remove(i+2);
				i += 2;
				this.salida = this.salida + "\nCommand: Jump to position ";
			} else if (insName.equals("veer")) {
				dir = instrs.get(i+1);
				manualVeer(dir);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
			} else if (insName.equals("look")) {
				dir = instrs.get(i+1);
				manualLook(dir);
				instrs.remove(i);
				instrs.remove(i+1);
				i++;
			} else if (insName.equals("Dmove")) {
				n = Integer.valueOf(instrs.get(i+1));
				dir = instrs.get(i+2);
				manualDMove(n, dir);
				instrs.remove(i);
				instrs.remove(i+1);
				instrs.remove(i+2);
				i+=2;
			} else if (insName.equals("Omove")) {
				n = Integer.valueOf(instrs.get(i+1));
				dir = instrs.get(i+2);
				manualOMove(n, dir);
				instrs.remove(i);
				instrs.remove(i+1);
				instrs.remove(i+2);
				i+=2;
			} else if (this.declaredVars.contains(insName)) {
				n = Integer.valueOf(instrs.get(i+1));
				this.vars.put(insName, n);
				instrs.remove(i);
				instrs.remove(i+1);
				this.salida = this.salida + "\nCommand: Variable assignment";
				i++;
			} 
		}
	}


JAVACODE
	private void manualVeer(String dir) {
		if (dir.equals("right")) {
			world.turnRight();
			this.salida = this.salida + "\nCommand: Veer right ";
		} else if (dir.equals("around")) { 
			world.turnRight();
			world.turnRight();
			this.salida = this.salida + "\nCommand: Veer around ";
		} else if (dir.equals("left")) {
			world.turnRight();
			world.turnRight();
			world.turnRight();
			this.salida = this.salida + "\nCommand: Veer left ";
		}
	}


JAVACODE
	private void manualLook(String dir)	{
		if (dir.equals("north")) {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look north ";
		} else if (dir.equals("south")) {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look south ";
		} else if (dir.equals("east")) {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look east ";
		} else if (dir.equals("west")) {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			this.salida = this.salida + "\nCommand: Look west ";
		}
	}



JAVACODE
	private void manualDMove(Integer n, String dir) { 
		if (dir.equals("front")) {
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Move to the front, face original direction ";
		} else if (dir.equals("right")) {
			world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the right, face original direction ";
		} else if (dir.equals("back")) {
			world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight(); world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the back, face original direction ";
		} else if (dir.equals("left")) {
			world.turnRight(); world.turnRight(); world.turnRight();
			world.moveForward(n, false);
			world.turnRight();
			this.salida = this.salida + "\nCommand: Move to the left, face original direction ";
		}
	}


JAVACODE
	private void manualOMove(Integer n, String dir) {
		if (dir.equals("north")) {
			if (world.facingWest()) {
				world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face north, move steps";
		} else if (dir.equals("south")) {
			if (world.facingEast()) {
				world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face south, move steps";
		} else if (dir.equals("east")) {
			if (world.facingNorth()) {
				world.turnRight();
			} else if (world.facingWest()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingSouth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face east, move steps";
		} else if (dir.equals("west")) {
			if (world.facingSouth()) {
				world.turnRight();
			} else if (world.facingEast()) {
				world.turnRight(); world.turnRight();
			} else if (world.facingNorth()) {
				world.turnRight(); world.turnRight(); world.turnRight();
			}
			world.moveForward(n, false);
			this.salida = this.salida + "\nCommand: Face west, move steps";
		}
	}


	ArrayList<String> saveInstr():
	{
		ArrayList<String> instr = new ArrayList<String>();
	}
	{
		(LOOKAHEAD(2) instr = saveCmd()
	|	instr = saveCtrlStruct()
	|	instr = saveProcCall()) { return instr; }
	}


	ArrayList<String> saveCmd():
	{
		ArrayList<String> cmd = new ArrayList<String>();
		ArrayList<String> l = new ArrayList<String>();
		int n, m;
	}
	{
		(( < NAME > { cmd.add(token.image); } ":=" n = num() { cmd.add(Integer.toString(n)); } )
	|	(< STEP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")" )
	|	(< JUMP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< JUMPTO > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } "," m = numVar() { cmd.add(Integer.toString(m)); } ")")
	|	(< VEER > { cmd.add(token.image); } "(" l = saveVeer() { cmd.addAll(l); } ")")
	|	(< LOOK > { cmd.add(token.image); } "(" l = saveLook() { cmd.addAll(l); } ")")
	|	(< DROP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< GRAB > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< GET > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< FREE > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< POP > { cmd.add(token.image); } "(" n = numVar() { cmd.add(Integer.toString(n)); } ")")
	|	(< DMOVE > { cmd.add(token.image); } "(" l = saveDMove() { cmd.addAll(l); } ")")
	|	(< OMOVE > { cmd.add(token.image); } "(" l = saveOMove() { cmd.addAll(l); } ")")) { return cmd; }
	}


	ArrayList<String> saveVeer() :
	{
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		((< RIGHT > { l.add(token.image); } )
	|	(< AROUND > { l.add(token.image); })
	|	(< LEFT > { l.add(token.image); })) { return l; }
	}


	ArrayList<String> saveLook() :
	{
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		((< NORTH > { l.add(token.image); })
	|	(< SOUTH > { l.add(token.image); })
	|	(< EAST > { l.add(token.image); })
	|	(< WEST > { l.add(token.image); } )) { return l; }
	}


	ArrayList<String> saveDMove() :
	{
		Integer n;
		ArrayList<String> l = new ArrayList<String>();
	}
	{ (n = numVar() { l.add(Integer.toString(n)); } ","
		(( < FRONT > { l.add(token.image); })
	|	( < RIGHT > { l.add(token.image); })
	|	( < BACK > { l.add(token.image); })
	|	( < LEFT > { l.add(token.image); }))) { return l; }
	}


	ArrayList<String> saveOMove() :
	{
		Integer n;
		ArrayList<String> l = new ArrayList<String>();
	}
	{ (n = numVar() { l.add(Integer.toString(n)); } "," 
		((< NORTH > { l.add(token.image); })
	|	(< SOUTH > { l.add(token.image); })
	|	(< EAST > { l.add(token.image); })
	|	(< WEST > { l.add(token.image); }))) { return l; }
	}


	ArrayList<String> saveCtrlStruct():
	{
		ArrayList<String> ctrlStruct = new ArrayList<String>();
	}
	{
		(ctrlStruct = saveIfFi()
	|	ctrlStruct = saveWhileDoOd()
	|	ctrlStruct = saveRepeatTimes()) { return ctrlStruct;}
	}


	ArrayList<String> saveIfFi():
	{
		boolean bool;
		ArrayList<String> instrs = new ArrayList<String>();
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		(< IF > "(" bool=condition() ")"
			"{" l = saveInstrIf(bool) { instrs.addAll(l); } ( ";" l = saveInstrIf(bool) { instrs.addAll(l); } )* "}"
		[< ELSE > 
			"{" l = saveInstrIf(!bool) { instrs.addAll(l); } ( ";" l = saveInstrIf(!bool) { instrs.addAll(l); } )* "}"
		] < FI >) {
		this.salida = this.salida + "\n'if' conditional control structure";
		return instrs;
		}
	}


JAVACODE
	private ArrayList<String> saveInstrIf(boolean bool) {
		ArrayList<String> l = new ArrayList<String>();
		if (bool) {
			l = saveInstr();
		} else {
			uselessInstr();
		}
		return l;
	}


	ArrayList<String> saveWhileDoOd():
	{
		boolean bool;
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		< WHILE > "(" bool=condition() ")" < DO > /* TODO: saveWhileInstrBlock(bool) */ < OD > {
			this.salida = this.salida + "\n'while' loop control structure";
			return l;
			}
	}


	ArrayList<String> saveRepeatTimes():
	{
		Integer n;
		ArrayList<String> l = new ArrayList<String>();
	}
	{
		( < REPEATTIMES > n = numVar() ) /* TODO: saveRepeatInstrBlock(n) */ ( < PER > ) {
			this.salida = this.salida + "\n'repeatTimes' loop control structure";
			return l;
		}
	}


	ArrayList<String> saveProcCall():
	{
		String name;
		ArrayList<String> rParams = new ArrayList<String>();
	}
	{
		(name = name() "(") [rParams = params()] ")" {
			if (!procsNames.contains(name)) {
				throw new Error("Tried to call undeclared procedure");
			}
			if (rParams.size() != procsParams.get(name).size()) {
				throw new Error("Incorrect number of parameters for "+name+" procedure");
			}
			// TODO: Guardar el llamado del procedimiento
		}
	}


	void uselessInstr():
	{
	}
	{
		LOOKAHEAD(2) uselessCmd()
	|	uselessCtrlStruct()
	|	uselessProcCall()
	}


	void uselessCmd():
	{
	}
	{
		( < NAME > ":=" < NUM >)
	|	(< STEP >  "(" numVar() ")" )
	|	(< JUMP >  "(" numVar() ")")
	|	(< JUMPTO >  "(" numVar() "," numVar() ")")
	|	(< VEER >  "(" veer() ")")
	|	(< LOOK >  "(" look() ")")
	|	(< DROP >  "(" numVar() ")")
	|	(< GRAB >  "(" numVar() ")")
	|	(< GET >  "(" numVar() ")")
	|	(< FREE >  "(" numVar() ")")
	|	(< POP >  "(" numVar() ")")
	|	(< DMOVE >  "(" dMove() ")")
	|	(< OMOVE >  "(" oMove() ")")
	}


	void uselessCtrlStruct():
	{
	}
	{
		uselessifFi()
	|	uselesswhileDoOd()
	|	uselessrepeatTimes()
	}


	void uselessifFi():
	{
		boolean bool;
	}
	{
		(< IF > "(" condition() ")" uselessInstrBlock()
		[< ELSE > uselessInstrBlock()	] < FI >) 
	}


	void uselesswhileDoOd():
	{
	}
	{
		< WHILE > "(" condition() ")" < DO > uselessInstrBlock() < OD >
	}


	void uselessProcCall():
	{
	}
	{
		name() "(" [params()] ")"
	}


	void uselessrepeatTimes():
	{
	}
	{
		< REPEATTIMES > numVar() uselessInstrBlock() < PER > 
	}


	String name():
	{
	}
	{
		< NAME > { return token.image; }
	}


	/**
	 * Unsigned decimal number
	 * @return the corresponding value of the string
	 * @error  corresponding value is too large
	 */

	Integer num() throws Error:
	{
		int total_;
		Integer total;
	}
	{
		<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
			return total;
		}
	}


	Integer numVar() throws Error:
	{
		int total_;
		Integer total;
	}
	{
		((<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
		})
	|	( (< NAME >) {
			if (vars.containsKey(token.image)) {
				total_ = vars.get(token.image);
				total = Integer.valueOf(total_);
			} else {
				throw new Error("Tried to use undeclared variable");
			}
		 })) { return total; }
	}


	Integer numVarParam(Hashtable<String, Integer> procParams) throws Error:
	{
		int total_;
		Integer total;
	}
	{
		((<NUM>
		{
			try 
			{
				total_ = Integer.parseInt(token.image);
				total = Integer.valueOf(total_);
			} 
			catch (NumberFormatException ee) 
			{
				throw new Error("Number out of bounds: "+token.image);
			}
		})
	|	(< NAME > {
			if (procParams.containsKey(token.image)) {
				total = procParams.get(token.image);
			} 
			else if (vars.containsKey(token.image)) {
				total = vars.get(token.image);
			} else {
				throw new Error("Tried to use unexsiting parameter or undeclared variable");
			}
		 })) { return total; }
	}
	

